列表
=====

这一章展示了Python中最有用的内置(built-in)类型之一：列表。你还会进一步关于对象(objects)的以及同一个对象有多个名称(name)时会发生什么。

列表是一个序列
--------------------

类似于字符串，一个**列表**是 一个值的序列!!!。在字符串中，每个值都是字符；在一个列表中，值可以使任何数据类型。一个列表中的值称为**元素**，或者是**项目**。

有多种方法可以常见一个新的列表；最简单的方法是用方括号"["和"]"将元素包括起来:

::

    [10, 20, 30, 40]
    ['crunchy frog', 'ram bladder', 'lark vomit']

第一个例子是包含4个整数的列表。第二个是一个包含3个字符串的列表。一个列表中的元素不需要是相同的数据类型。下面的列表包含一个字符串，一个浮点数，一个整数和另一个列表:

::

    ['spam', 2.0, 5, [10, 20]]

一个列表在另一个列表中，称为嵌套。

一个不包含元素的列表称为空列表。你可以用空的方括号``[]``创建一个空列表。

正如你可能期望的，你可以将列表的值赋给变量：

::

    >>> cheeses = ['Cheddar', 'Edam', 'Gouda']
    >>> numbers = [42, 123]
    >>> empty = []
    >>> print(cheeses, numbers, empty)
    ['Cheddar', 'Edam', 'Gouda'] [42, 123] []

列表是可变的
-----------------

访问列表中元素的语法和访问字符串中字符的语法相同，都是通过 括号！！！（方括号）运算符实现的。括号中的表达式指定了 下标！！！（索引位置）。记住，下标从0开始：

::

    >>> cheeses[0]
    'Cheddar'

和字符串不同，列表是可以改变的。当括号运算符出现在赋值语句的左边，它就指向了列表中将被赋值的元素。

::

    >>> numbers = [42, 123]
    >>> numbers[1] = 5
    >>> numbers
    [42, 5]

numbers中下标为1的元素，原来是 123，现在是 5.

图 [fig.liststate] 展示了cheeses, number 和 empty 的状态图：

.. figure:: figs/liststate.pdf
   :alt: State diagram.

   状态图.

列表用外部标有"list"的盒子表示，盒子内部是列表的元素。 cheeses 是！！！（对应refers）一个有3个元素的列表，3个元素的下标分别是0,1,2。numbers包含两个元素；状态图显示了第二个元素原来是 123，被重新赋值为 5。 empty对应一个没有元素的列表。

列表下标的工作原理和字符串的相同：

-  任何整数表达式可以作为下标。

-  如果你试图读或写一个不存在的元素，你将会得到一个索引错误(IndexError).

-  如果下标是负数，它将从列表的末端开始访问列表。

in 运算符在列表中同样可以使用。

::

    >>> cheeses = ['Cheddar', 'Edam', 'Gouda']
    >>> 'Edam' in cheeses
    True
    >>> 'Brie' in cheeses
    False

遍历一个列表
-----------------

最常用的遍历列表的方式是使用for循环。语法和字符串类似：

::

    for cheese in cheeses:
        print(cheese)

如果你只需要读取列表中的元素，这种方法已经足够。然而，如果你想要写入或者更新列表中的元素，你需要通过下标访问。一种常用的方法是结合内置函数range和len：

::

    for i in range(len(numbers)):
        numbers[i] = numbers[i] * 2

这个循环对列表进行遍历并更新每个元素。len返回列表中的元素个数。range返回一个从0到:math:`n-1`下标的列表，其中:math:`n`是列表的长度。每次循环中，i得到下一个元素的下标。循环主体中的赋值语句使用i读取该元素旧值并且赋予其一个新值。

对一个空列表的for循环将不会执行循环的主体：

::

    for x in []:
        print('This never happens.')

尽管一个列表可以包含另一个列表，一个嵌套到另一个列表中的列表本身还是被看作一个单个元素。下面这个列表的长度是4:

::

    ['spam', 1, ['Brie', 'Roquefort', 'Pol le Veq'], [1, 2, 3]]

列表操作
---------------

+ 运算符连接多个列表:

::

    >>> a = [1, 2, 3]
    >>> b = [4, 5, 6]
    >>> c = a + b
    >>> c
    [1, 2, 3, 4, 5, 6]

运算符*以给定次数的重复一个列表:

::

    >>> [0] * 4
    [0, 0, 0, 0]
    >>> [1, 2, 3] * 3
    [1, 2, 3, 1, 2, 3, 1, 2, 3]

第一个例子重复4次.第二个例子重复了那个列表3次。

列表切片
-----------

切片运算符同样对列表适用:

::

    >>> t = ['a', 'b', 'c', 'd', 'e', 'f']
    >>> t[1:3]
    ['b', 'c']
    >>> t[:4]
    ['a', 'b', 'c', 'd']
    >>> t[3:]
    ['d', 'e', 'f']

如果你忽略了第一个索引，切片将从列表头开始。如果你忽略了第二个，切片将会到列表尾结束。所以如果你两者都忽略，切片就是整个列表的一个拷贝。

::

    >>> t[:]
    ['a', 'b', 'c', 'd', 'e', 'f']

由于列表是可变的，通常在对列表进行修改的操作之前做一个列表的拷贝会是很有用的。

赋值语句左边的切片运算符可以更新多个元素:

::

    >>> t = ['a', 'b', 'c', 'd', 'e', 'f']
    >>> t[1:3] = ['x', 'y']
    >>> t
    ['a', 'x', 'y', 'd', 'e', 'f']

列表方法
------------

Python为列表提供了一些方法. 例如, append 添加一个新元素到列表的末端:

::

    >>> t = ['a', 'b', 'c']
    >>> t.append('d')
    >>> t
    ['a', 'b', 'c', 'd']

extend将一个列表作为参数，并以append方式添加其中的所有元素:

::

    >>> t1 = ['a', 'b', 'c']
    >>> t2 = ['d', 'e']
    >>> t1.extend(t2)
    >>> t1
    ['a', 'b', 'c', 'd', 'e']

这个例子中t2没有改动.

sort 对列表中的元素从小到大进行排序:

::

    >>> t = ['d', 'c', 'e', 'b', 'a']
    >>> t.sort()
    >>> t
    ['a', 'b', 'c', 'd', 'e']

大部分列表的方法都是空的；他们对列表进行修改然后返回None。如果你意外的写了t.sort()，你将会对结果失望的。

映射，筛选和归并
----------------------

对列表中所有元素求和，你可以这么使用循环:

::

    def add_all(t):
        total = 0
        for x in t:
            total += x
        return total

total 被初始化为 0. 每次经过循环, x 从列表中读取一个元素. 运算符+=提供了一个快捷的更新变量的方法。. 这是增量赋值语句,

::

        total += x

等价于

::

        total = total + x

当循环执行时，totel记录了元素的和; 一个这样的变量有时称为一个**累加器**.

把一个列表中的元素加起来是一个很常用的操作，所以Python将其设置为一个内建！！！（内置）函数sum:

::

    >>> t = [1, 2, 3]
    >>> sum(t)
    6

一个像这样的将一系列的元素合并到成一个单一值的操作有时称为**归并**。

有时在你构建一个列表时需要遍历另一个列表。例如，下面的函数读取一个字符串列表作为参数，返回大写后的新列表：

::

    def capitalize_all(t):
        res = []
        for s in t:
            res.append(s.capitalize())
        return res

res 被初始化为一个空的列表; 每次循环我们附加下一个元素，所以res是另一种累加器.

类似``capitalize_all``的操作有时被称为**映射(map)**，因为它“映射”一个函数（在本例中是方法capitalize）到序列中的每个元素上。

另一个常见的操作是从列表中选择一些元素，并返回一个子列表。举例来说，下面的函数读取一个字符串列表，并返回一个仅包含大写字符串的列表:

::

    def only_upper(t):
        res = []
        for s in t:
            if s.isupper():
                res.append(s)
        return res

isupper 是一个字符串方法，如果字符串仅含有大写字母，则返回True。

一个类似``only_upper``的操作称为**筛选**，因为它选出一部份元素，而滤掉其它元素。

大部分常用列表操作可以被表示为一个映射、筛选和归并的结合。

删除元素
-----------------

有多种方法去从列表中删除一个元素。如果你知道元素的下标，你可以使用pop:

::

    >>> t = ['a', 'b', 'c']
    >>> x = t.pop(1)
    >>> t
    ['a', 'c']
    >>> x
    'b'

pop 修改列表，并返回被移除的元素. 如果你不提供下标，它将移除最后一个元素并返回其值。

如果你不需要被移除的元素，可以使用del运算符:

::

    >>> t = ['a', 'b', 'c']
    >>> del t[1]
    >>> t
    ['a', 'c']

如果你知道要删除的值，但是不知道其下标，你可以使用remove:

::

    >>> t = ['a', 'b', 'c']
    >>> t.remove('b')
    >>> t
    ['a', 'c']

remove的返回值是None.

要移除不止一个元素，你可以结合切片索引使用del:

::

    >>> t = ['a', 'b', 'c', 'd', 'e', 'f']
    >>> del t[1:5]
    >>> t
    ['a', 'f']

同样的，切片选择到第二个下标（不包含第二个下标）中的所有元素

列表和字符串
-----------------

一个字符串是一个字符的序列，一个列表是一个值的序列。但是一个字符的列表不同于字符串。可以使用list讲一个字符串转换为字符的列表:

::

    >>> s = 'spam'
    >>> t = list(s)
    >>> t
    ['s', 'p', 'a', 'm']

由于list是内建函数名，所以你应避免使用它作为一个变量名。我同样避免使用l，因为它看起来很像1，因此我使用t。

list函数将字符串分割成单独的字符。如果你想将一个字符串分割成一些单词，你可以使用split方法:

::

    >>> s = 'pining for the fjords'
    >>> t = s.split()
    >>> t
    ['pining', 'for', 'the', 'fjords']

一个叫做**分隔符**的可选参数指定了什么字符作为单词之间的分界线。下面的例子使用连字符作为分隔符:

::

    >>> s = 'spam-spam-spam'
    >>> delimiter = '-'
    >>> t = s.split(delimiter)
    >>> t
    ['spam', 'spam', 'spam']

join功能和split相反。它将一个字符串列表的元素连接起来。join是一个字符串方法，所以你需要在一个分隔符上调用它，并传入一个列表作为参数:

::

    >>> t = ['pining', 'for', 'the', 'fjords']
    >>> delimiter = ' '
    >>> s = delimiter.join(t)
    >>> s
    'pining for the fjords'

在这个例子中分隔符是一个空格，所以join在单词之间添加一个空格。如果不使用空格连接字符串，你可以使用空字符串``''``作为分割符。

对象和值
------------------

如果我们执行以下的赋值语句:

::

    a = 'banana'
    b = 'banana'

我们知道a和b都指向一个字符串，但是我们不知道是否他们指向*同一个*字符串。这里有两种可能的状态，在下图[fig.list1]中表示了出来：

.. figure:: figs/list1.pdf
   :alt: State diagram.

   状态图.

在一种情况中，a和b指向两个有相同值的不同对象。在第二种情况中，它们指向同一个对象。

为了查看是否两个变量指向同一个同一个对象，你可以使用is运算符。

::

    >>> a = 'banana'
    >>> b = 'banana'
    >>> a is b
    True

在这个例子中，Python仅生成了一个字符串对象，a和b都指向它。但是当你创建两个列表，你将得到两个对象:

::

    >>> a = [1, 2, 3]
    >>> b = [1, 2, 3]
    >>> a is b
    False

状态图看起来是如图 [fig.list2]这样的.

.. figure:: figs/list2.pdf
   :alt: State diagram.

   状态图.

在这个例子中，我们称这两个列表是**相等**的，因为它们有相同的元素。但它们不是**相同**的，因为他们不是同一个对象。如果两个对象是**相同**的，它们也是相等的，但是如果它们是相等的，他们不一定是相同的。

目前，我们一直交换的使用"对象"和“值”，但是更精确的说是一个对象拥有一个值。如果你运行 ！！！（缺失？），你会得到一个值为一个整数序列的列表对象。如果另一个列表有同样的元素，我们说它有相同的值，但是它并不是同一个对象。

别名使用
--------

如果a指向一个对象，然后你赋值b = a，那么两个变量指向同一个对象:

::

    >>> a = [1, 2, 3]
    >>> b = a
    >>> b is a
    True

状态图如图 [fig.list3]所示.

.. figure:: figs/list3.pdf
   :alt: State diagram.

   状态图.

一个变量和一个对象之间的关联称为**reference**。在这个例子中，有两个对同一个对象的引用。

如果一个对象有多于一个引用，我们成这个对象是**有别名的**。

如果一个有别名的对象是可变的，对其中一个别名的改变对影响到其它的别名：

::

    >>> b[0] = 42
    >>> a
    [42, 2, 3]

尽管这个行为很有用，但是容易造成错误。通常，对于可改变的对象避免使用别名相对更安全。

对于不可改变的对象，使用别名没有什么问题。例如：

::

    a = 'banana'
    b = 'banana'

使用a或b指向同一个字符串基本上没有任何区别。

列表参数
--------------

当你将一个列表作为参数传给一个函数，函数将得到这个列表的一个引用。如果函数对这个列表参数进行了修改，在原来的列表中会看见变动。例如， ``delete_head``删除列表的第一个元素：

::

    def delete_head(t):
        del t[0]

它是这么起作用的:

::

    >>> letters = ['a', 'b', 'c']
    >>> delete_head(letters)
    >>> letters
    ['b', 'c']

参数 t 和变量 letters 是同一个对象的别名。栈图如下 [fig.stack5].

.. figure:: figs/stack5.pdf
   :alt: Stack diagram.

   栈图.

由于列表被两个帧共享，我把它画在它们中间。

需要注意的是修改列表操作和创建列表操作间的区别，例如， append 方法是修改一个列表，而 + 运算符是创建一个新的列表：

::

    >>> t1 = [1, 2]
    >>> t2 = t1.append(3)
    >>> t1
    [1, 2, 3]
    >>> t2
    None

append修改列表并返回None。

::

    >>> t3 = t1 + [4]
    >>> t1
    [1, 2, 3]
    >>> t3
    [1, 2, 3, 4]
    >>> t1

运算符 + 创建了一个新列表，而不改变原始的列表。

如果你要编写一个修改列表的函数，这一点就很重要。例如，这个函数*不会*删除列表的第一个元素：

::

    def bad_delete_head(t):
        t = t[1:]              # WRONG!

切片操作创建了一个新列表，然后这个表达式让 t 指向了它，但是并不会影响原来被调用的列表。

::

    >>> t4 = [1, 2, 3]
    >>> bad_delete_head(t4)
    >>> t4
    [1, 2, 3]

在 ``bad_delete_head``的开始，t和t4指向同一个列表。在结束时，t指向一个新列表，但是t4仍然指向原来的没有被改动列表。

一个替代的写法是写一个函数来创建并返回一个新的列表。例如，tail返回列表中除了第一个之外的所有元素：

::

    def tail(t):
        return t[1:]

这个函数不会修改原来的列表。这里展示了它是怎么使用的：

::

    >>> letters = ['a', 'b', 'c']
    >>> rest = tail(letters)
    >>> rest
    ['b', 'c']

调试
---------


粗心的使用列表（以及其他可改变的对象）会导致长时间的调试。下面给出一些常见的陷阱以及避免它们的方法：

#. 大多数的列表的方法对参数进行修改，然后返回None。这和字符串的方法相反。字符串的方法会保留原始的字符串并返回一个新的字符串。

   如果你习惯这样写字符串代码：

   ::

       word = word.strip()

   那么你很可能会写出下面的代码：

   ::

       t = t.sort()           # WRONG!

   因为sort返回None，所以你的下一个对t执行的操作很可能会失败。

   在使用list方法和操作符之前，你应该仔细的阅读文档然后在交互模式下测试。

#. 养成自己的代码风格.

   列表的一个问题就是有太多途径去做同样的事情。例如，要删除列表中的一个元素，你可以使用pop，remove，del甚至切片赋值。

   要添加一个元素，你可以使用append方法或者+运算符。假设t是一个列表，x是一个列表元素，以下是正确的：

   ::

       t.append(x)
       t = t + [x]
       t += [x]

   而这些是错误的：

   ::

       t.append([x])          # WRONG!
       t = t.append(x)        # WRONG!
       t + [x]                # WRONG!
       t = t + x              # WRONG!

   在交互模式下测试每一个例子，保证你明白它们做了什么。注意只有最后一个会导致运行时错误，其他的都是合乎规范的的，但做了错误的事情。

#. 通过创建拷贝来避免别名.

   如果你要使用类似 sort 的方法来修改参数，但同时有要保留原列表，你可以创建一个拷贝。

   ::

       >>> t = [3, 1, 2]
       >>> t2 = t[:]
       >>> t2.sort()
       >>> t
       [3, 1, 2]
       >>> t2
       [1, 2, 3]

   在这个例子中你还可以使用内建函数 sorted，它将返回一个新的已排序的列表，原列表将保持不变。

   ::

       >>> t2 = sorted(t)
       >>> t
       [3, 1, 2]
       >>> t2
       [1, 2, 3]

术语
--------

列表:
    一个值的序列。

元素:
    列表（或序列）中的一个值，也称为项目。

嵌套列表:
	一个作为另一个列表的元素的列表。

累加器:
    循环中用于相加或累积出一个结果的变量。


增量赋值:
    一个使用类似``+=``操作符来更新一个变量的值的语句。

归并:
    遍历序列，将所有元素求和为一个值的处理模式。

映射:
    遍历序列，对每个元素执行操作的处理模式。

筛选:
    遍历序列，选出满足一定标准的元素的处理模式。

对象:
    变量可以指向的东西。一个对象有其数据类型和值。

相等:
    有相同的值。

相同:
    是同一个对象（隐含着相等）。

引用:
    一个变量和它的值之间的关联。

别名使用:
    一种两个或者两个以上变量指向同一个对象的情况。

分隔符:
    一个用于指示字符串分割位置的字符或者字符串。

练习
---------

你可以从http://thinkpython2.com/code/list_exercises.py下载这些联系的解答。

写一个叫做``nested_sum``的函数，这个函数读取一个由一些整数列表构成的列表，并将所有的嵌套列表中的元素相加。例如：

::

    >>> t = [[1, 2], [3], [4, 5, 6]]
    >>> nested_sum(t)
    21

[cumulative]

写一个叫做cumsum的函数，读取一个数值列表并返回累加和，即一个新列表，其中第:math:`i`\个元素是元列表中前:math:`i+1`个元素的和。例如：

::

    >>> t = [1, 2, 3]
    >>> cumsum(t)
    [1, 3, 6]

写一个叫做``middle``的函数，读取一个列表，并返回一个除了第一个和最后一个元素的列表。例如：

::

    >>> t = [1, 2, 3, 4]
    >>> middle(t)
    [2, 3]

写一个叫做``chop``的函数，读取一个列表，移除第一个和最后一个列表，并返回None。例如：

::

    >>> t = [1, 2, 3, 4]
    >>> chop(t)
    >>> t
    [2, 3]

写一个叫做``is_sorted``的函数，读取一个列表，如果列表是递增排列的则返回True，否则返回False。例如：

::

    >>> is_sorted([1, 2, 2])
    True
    >>> is_sorted(['b', 'a'])
    False

[anagram]

如果可以通过重拍一个单词中字幕的顺序得到另外一个，那么称这两个单词是变位词。写一个叫做``is_anagram``的函数，读取两个字符串，如果它们是变位词则返回True。

[duplicate]

写一个叫做``has_duplicates``的函数，读取一个列表，如果一个元素在列表中出现了不止一次则返回True。这个函数不能改变原列表。

这个练习是关于一个叫做生日悖论的问题。你可以在http://en.wikipedia.org/wiki/Birthday_paradox中了解更多相关的内容。

如果你的班级上有 23 个学生， 2 个学生生日相同的概率是多少？你可以通过随即产生
23 个生日并检查匹配来估计概率。提示：你可以使用 random 模块中的 randint 函
数来生成随即生日。

你可以从http://thinkpython2.com/code/birthday.py.下载我的解答。


编写函数，读取文件 words.txt，建立一个列表，每个单词为一个元素。编写两个版本函数，一个使用 append 方法，另一个使用 t = t + [x]。那个版本运行得慢？为什么？
解答: http://thinkpython2.com/code/wordlist.py.

[wordlist1] [bisection]

检查一个单词是否在单词表中，你可以使用 in 运算符，但这很慢，因为它按顺序查找单词。

由于单词是按照字母顺序排序的，我们可以使用两分法（也称二进制搜索）来加快速度，类似你在字典中查找单词的方法。你从中间开始，如果你要找的单词在中间的单词之前，你查找前半部分，否则你查找后半部分。

每次查找，你将搜索范围减小一半。如果单词表有 113,809 个单词，你只需要 17步来找到这个单词，或着知道单词不存在。

写一个叫做``in_bisect``，参数为一个已排序的列表和一个目标值，返回该值在列表中的位置，如果不存在则返回 None。

或者你可以阅读bisect模块的文档并使用它！
解答: http://thinkpython2.com/code/inlist.py.

两个单词被称为是“反转词对”，如果一个是另一个的反转。编写函数，找出单词表中所有的反转词对。
解答: http://thinkpython2.com/code/reverse_pair.py.

两个单词被称为是“连锁词”，如果交替的从两个单词中取出字符将组成一个新的单词。例如，“ shoe”和“ cold”连锁后成为“ schooled”。
解答: http://thinkpython2.com/code/interlock.py. 致谢: 这个练习的灵感由这个网站中的一个例子而来：http://puzzlers.org.

#. 编写程序，找出所有的连锁词。提示：不要列举所有的单词对。

#. 你能够找到三重连锁的单词吗？即每个字母依次从 3 个单词得到。